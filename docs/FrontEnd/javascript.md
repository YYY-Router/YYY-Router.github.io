##### 1.驼峰命名法

​		首字母小写，剩下的每个单词的首字母大写
​			helloWorld
​				xxYyyZzz

##### 2.数据类型

​		String 字符串  var str = "hello";  (双引号单引号都可以)“\表示转义字符”  
​		Number 数值
   （基本数据类型）Null 空值

​								  Boolean 布尔值
​								  Undefined 未定义
​     
​    （引用数据类型）Object 对象

不加“ ”表示数字类型，加上了以后表示字符串类型

##### 3.typeof 是用来检查数据类型的字符

```
console.log(typeof a);
```

##### 4.js中可以保存的最大值

```JavaScript
Number.MAX_VALUE
```

如果用number表示的数超过了最大值，则会返回 Infinity

```
Infinity 表示正无穷
-Infinity 表示负无穷
```

```
Number.MIN_VALUE 表示最小值（0以上的）
```

##### 5.NaN表示 not a number

##### 6.js可以保基本的整数计算准确，但是使用js计算浮点数（小数）可能会得到一个错误的结果

##### 7.布尔值只有两个

```
（用来表示真假）
ture 表示真的
false 表示假的
主要用来表示逻辑判断
```



##### 8.null 这个值专门用来表示一个为空的对象 （是object）

undefined 当声明一个变量但是不赋值时，就表示undefined

##### 9.数据类型转换 （将其他数据类型转换成String）

​	方法一  

```
调用xxx的yyy()方法，就是xxx.yyy()
	调用数据类型的toString()方法
	var a = 123;
	var b= a.toString();
	此时b就为字符串的数据类型
该方法不会影响原类型，null和undefined这两个值无toString()值，如果调用则会报错
```

​	方法二

```
调用String(）函数	
	var a = 123;
	 a = String(a);
	此时就把number转换成了string类型
使用String()做函数类型转换，实际上就是调用toString转换方法
，但是对于null和undefined就不会调用toString 
直接就把它们转换成“null”“undefined”
```

##### 10.把其他数据类型转换成number

​	方法一 

```
使用Number()函数
	var a = "123";
	a = Number(a);
字符串转数值：
如果是纯数字字符串，则直接将其转换成数字
如果字符串中有非数字的内容则转换成NaN
如果原字符串为空串，则转换成数值类型后就转换成0
true转成1，false转换成0
null转换成数值后为0
undefined转换成数字NaN
```

​	转换方式二

```
（专门用来对付122as这样的字符串）
	parseInt() //把一个字符串中的有效整数取出来(从左到右依次读取，遇到第一个非数字就停止)
	a = parseInt(a);
	parseFloat() //和上面的parseInt功能类似，但是会取出小数
如果对非string类型，使用上面方法转化，则先会自动对该类型转换成string类型，再进行相关的转换
```

##### 11.在js中如果需要表示16进制的数字，应该先在前写0x，输出的时候会转换成十进制

```
例如：0xff，0x10
```

如果表示8进制的数字，应该再前面写0

```
例如：08,09
```

如果要表示二进制（用得少，并不是所有的浏览器都支持）则需要用0b开头

```
例如：0b12
```

注意：像070这样的数字不同浏览器会有不用的结果（可能会解析成8进制，也能会解析成十进制）
解决办法;

```
a = parseInt(a,10);   //此方法就是转换成十进制，适用所有的浏览器
```

##### 12.把其他的数据类型转换成布尔值

>>对数字类型使用Boolean()函数
>>除了0和NaN其余的都会转换成ture

>>对字符串转换
>>除了空串，其余都是ture

>>对于null和undefined转换
>>都会转换成false

>>对象也会转换成ture

#####  13.运算符

```
 例如：typeof 就是一个运算符
	var a = 123;
		var result = typeof a;
			console.log(result);
```



>>算数运算符
>
>>```
>>（一般不会对原变量的结果进行改变）
>>当对非number值进行算数运算时，会先自动转换成number类型，再进行计算
>>		result = ture+1；
>>			输出为2
>>任何值和NaN进行运算，结果都为NaN
>>如果对两个字符串进行加法运算，则会进行字符串拼接
>>		result = “你好”+“世界”；
>>			输出为：你好世界
>>```
>
>

注意：任何的值和字符串做“加法”运算，都会先转换成字符串，再进行拼接字符串
利用如上特性，可以为任意的数据类型加上个空串，就转换成string 数据类型
	

```
			var c = 123;
				c = c+"";
	则此时输出c的数据类型就是string类型
			console.log("c="+c); 输出时“c=”也会显示
```



>>```
>>>>除了加法中字符串拼接的特殊情况，其他的运算无论谁和谁进行“减法，乘法，除法"运算
>>>>都会先转换成number数据类型，在进行运算
>>>>可以利用上述特点进行数据类型转换
>>>>-0，*1，/1
>>```
>
>>>>% 取模运算
>>>>取余数，最后的结果为余数
>
>>```
>>
>>```
>
>

##### 14.一元运算符

+ 正号 ，不会对数值产生任何影响

- 负号，会对数字进行取反

  ```
  对于非number类型使用时，会先对其转换成number类型，再进行运算
  		a = "18";
  		a = +a;
  此时输出的数据类型为number
  ```

  ##### 15.自增运算

  ```
  自增分为两种：后++（a++），前++（++a）
  对于一个变量使用“a++”或者“++a”后均会影响原变量的值
  a++;的值等于自增以前的值
  ++a；的值等于自增后的值
  自减运算：规则同上 
  ```

  ##### 16.逻辑运算

  ###### （布尔值）

  js中有三种逻辑运算符：

>>				! 非  可以对一个布尔值进行取反运算;若对非布尔值进行运算，则会先进行
>>			布尔值的转换，再进行取反运算
>>			故可以利用该特点，对数据类型转化（取两次非运算，就可以改变数据类型）
>>			例如：
>>			`var b = 123；`
>>			`b = ！！b；`

>>				&& 与  可以对符号两侧的值进行运算并返回结果（一假则假）《相当于爱情》
>>			```
>>			var result = ture&&ture;  真
>>			var result = false&&false; 假
>>			var result = false&&ture; 假
>>			var result =ture&&false；假
>>			与是属于短路的与，遇到假就立即停止，不会再检查第二个
>>				|| 或 可以对符号两侧的值进行运算时并返回结果（一真则真）
>>			var result = ture||ture;  真
>>			var result = false||ture;  真
>>			var result = ture||false;  真
>>			var result =false||false；假
>>			```
>
>>		###### （非布尔值）
>
>>		对于非布尔值进行与或运算时，会先把其转化成布尔值，在进行运算，并且返回原值与运算	
>>		`var result = 1&&2;`
>>		当两个值都为ture时，则返回后面的那个（例如上式就返回2）
>>		如果进行与运算时有false时，则返回靠前的false值
>>		`var result = 1&&0;`
>>		规则：
>>		如果第一个值为ture，则必然返回第二个值
>>		如果第一个值为false，则必然返回第一个值
>>		或运算
>>		规则：
>>		如果第一个值为ture，则直接返回第一个值
>>		如果第一个值为false，则直接返回第二个值

##### 17.赋值运算符

```
“=”可以把符号右侧的值赋给符号左侧的变量（右给左）
“+=”a+=5；等价于a=a+5；
“-=”
“*=”	（效果均与“+=”相同）
“/=”
“%=”
```

##### 18.关系运算符

（比较两个值之间的大小关系）

> ```
> 判断左侧值是否大于右侧值，如果关系成立则返回ture，反之则返回false
> var result = 5>10;
> 此时result输出的结果为false
> ```
>
> ```
> “=” 判断符号左侧的值是否大于或者等于右侧的值，如果关系成立则返回ture，反之则返回false
> 对于非数值进行比较时，会将其转换成数字，再进行比较
> 任何值和NaN进行比较时，结果都是false
> 如果符号两边都是字符串，则他不会将其转换成数字类型，而是直接比较其字符编码uncode
> 比较字符编码时，是一位一位的比较。如果两位一样，则比较下一位，所以借用他来对英文排序
> ```

```
uncode编码使用（表格中是16进制的）
js中使用转义字符“\u”来输出（16进制的）
例：console.log("\u2620"); 输出的时候就显示编码
在网页中使用uncode编码
&#加上编码（十进制的）
例：<h1>&#编码</h1>`
```



##### 19.相等运算符

“== ”用来比较两个值是否相等，若相等则返回ture，反之则返回false

```
	var a = 10;
	console.log(a == 1);
	此实例就输出为false
```

如果两个值的比较类型不同时，则会先转换成相同的类型，再进行比较（大部分情况会转换成数字）

```
undefined衍生自null，所以两个值在进行比较时会返回ture
NaN不和任何值相等，包括他的本身
可以通过isNaN（）函数来判断是否为NaN，若符合则返回ture，反之返回false
	console.log(isNaN（a）);
```

“！=”用来判断不相等运算，，若符合则返回ture，反之返回false

```
	console.log(10！=5);
```

“===”全等于，用来判断两个值是否全等，与“==”不同的是他不会自动做类型转换，如果类型不同就直接返回false，其他的与“==”相同。

“！==”不全等，用来判断两个值是否不全等，他和“！=”不同的是，他不会自动做类型判断，其他的和
“！=”的规则相同

##### 20.for循环

在for循环中需要有
初始化表达式，条件表达式，更新表达式

	for(初始化表达式；条件表达式；更新表达式){
		语句
	}

如果for中的任何语句都不写，则会是生成一个死循环

```
	for(var i = 0;i < 10;i++){
		alert(i);
}
```

##### 21.对象

创建对象

```
使用new关键字调用的函数，是构造函数constructor
	var obj = new Object();
在对象中保存的值为属性
```

可以向对象中添加属性

```
	对象.属性名=属性值；
		obj.name = "孙悟空"
		obj.gender = "男"
```

读取对象中的属性

```
	对象.属性名
			console.log(obj.name);
	读取对象中没有属性，不会报错，会显示未定义
```

修改对象的属性值

```
	对象.属性名 = 新属性值；
		obj.name = "tom"
```

删除对象属性

```
	delete 对象.属性名
		delete obj.name
```

对象的属性名，不强制要求遵循标识符规范，什么乱七八糟的名字都可使用，但是尽量规范去写
	

```
如果要使用特殊的属性名可以使用[]来操作
	语法：对象["属性名"] = 属性值；
		obj["123"] = 789;
```

使“[ ]”去操作属性更加灵活，在括号中可以直接传递一个变量，这样变量的值是多少，对象就会读取那个属性

```
		var obj = new Object();
			obj.nihao = "你好"；
			var n = "nihao";
		console.log(obj.[n])
	此时就会读取到nihao属性，可以将一个对象设置为另一个对象的属性
	var obj = new Object();
	obj.nihao = "你好"；
	var obj2 = new Object();
	obj.name = "tom"
	obj.nihao = obj2;
读取对象时可以用
		console.log(obj.nihao.name);
```

in 运算符，可以检查一个对象中是否含有指定属性，有则返回ture，反之返回false。

```
		"属性名" in 对象
	例：
		console.log("test2" in obj);
```

基本数据类型与对象的区别：

```
变量是保存到栈内存中，值与值之间是独立存在的，修改谁都互不影响。
对象是保存到堆内存当中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象内存的地址（对象的引用），如果两个变量保存的为同一个对象的引用，当通过一个变量修改属性时，另一个也受到影响。但是当修改对象的值的时候，是不会影响其他对象的。
即使两个对象一模一样，但是也是两个对象，并不相同。
因为两个对象的地址不同，所以返回false
```

<img src="https://yulearn.top/webSource/img/stackImg.png" style="zoom:50%;" />

##### 22.对象字面量

使用字面对面量来创建对象

```
		var obj = {};
		obj.name = "tom";
```

使用对象字面量可以在创建对象时直接制定对象属性

```
		{属性名：属性值，属性名：属性值}；
```

对象的属性名可以加引号也可以不加，但是要是使用一些特殊的的名字需要加引号
名与值之间用“：”连接。如果一个属性是最后的一个属性，那么逗号就不用写

		var obj = {
		name:"tom",
		age:28,
		test:{name:"sam"}	
	 	    };

##### 23.函数

- 函数也是一个对象

- 函数中可以封装一些功能（代码），在需要的时候可以执行这些功能（代码） 

- 函数中可以保存一些代码在需要的时候调用
  创建一个函数对象

  ```
    var fun = new Function();  很少用这种方式构造函数
  ```

  可以将要封装的代码一字符串的形式传递给构造函数

  ```
  var fun = new Function("console.log('hello!');");
  ```

  封装到函数中的代码不会立即执行，函数中的代码会在函数调用的过程中执行
  调用函数语法：函数对象（）；

  ```
  	fun();
  ```

  （常用）使用函数声明来创建一个函数

  ```
  	function 函数名（[形参1，形参2,形参.....]）{     //[]中可以不写
  	语句......
  }		
  ```

```
例：
	function fun2(){
		语句...
		}
		//调用函数
			fun2();
```

使用函数表达式来创建一个函数

```
	var 函数名 = function([形参1，形参2,形参.....]){
		语句....
	}
```

```
例：
	var fun3 = function(){
		语句...
		}
```

##### 24.可以在函数括号中来指定多个形参，多个形参之间用“，”隔开

定义一个用来求两个数和的函数

```
	function sum(a，b){
		console.log(a+b);
	}
```

在调用函数中可以指定实参，实参会赋值给函数中对应的形参

```
	sum(1,2);
```

在调用函数时解析器不会检查实参的类型，故应该注意是否会接收到非法的参数，否则会出现:

```
	sum(ture,123);
```

在调用函数时，解析器也不会检查实参的数量，多余的实参不会被赋值

```
	sun(123,456,789)；
```

如果实参的数量少于形参的数量，则没有对应的形参将会是undefined

##### 25.返回值

可以使用return来设置函数返回值（可以返回任意值）

```
return 值；
```

return后的值将会作为函数的执行结果来返回，故可以定义一个变量来接收结果

```
var result = sum(1,2,3);
	function sum(a,b,c){
		var d = a+b+c;
		return d;
	}
var result = sum(1,2,3);
		console.log(result);
```

return后的语句都不会执行了
如果return后不跟任何值，或者不写return，则会返回undefined。

##### 26.判断一个数是否为偶数

		function isou(num){
			return num%2 == 0;	
		}
	
	var result = isou(3);

当参数过多时，可以将参数封装到一个对象里，进行传递，并且实参也可以是一个函数。

```
	fun(isou(10));
```

加括号调用函数,相当于使用函数的返回值，被调用的函数的返回值是啥，实参就是啥。

```
	fun(isou);
```

不加括号调用函数就相当于直接使用函数对象

##### 27.结束循环

```
return可以结束整个函数
break可以结束循环
continue可以结束当次的循环
return后的返回值可以是任意的值，可以是参数，可以是数字，也可以是对象
在函数内部还可以声明函数
```

##### 28.立即执行函数

匿名函数用（）包起来，在结尾加上括号相当于调用函数，（）中可以传参

```
  (function () {
            alert("我是一个匿名函数！")
        })();
```

函数定义完，立即被调用，叫做立即执行函数

```
对象的属性值可以是任何数据类型，可以是对象，可以是函数
如果一个函数作为一个对象的属性保存，那么我们称这个函数为这个对象的方法
调用函数就说是调用对象的方法（method）
但是他只是名称上的区别，而没有其他的区别
```

##### 29.枚举对象中的属性

​	for...in语句

	for（var  变量n in 对象）{
		}

对象中有几个属性，for in循环就执行几次，
每次执行时就会把属性名赋值给变量n

##### 30.作用域

js中一共有两种作用域

###### 全局作用域

- 直接写在 script标签中，都在全局作用域
- 全局作用域在页面打开时创建，在页面关闭时销毁
- 在全局作用域中有一个全局对象window，
  代表的是一个浏览器的窗口，他由浏览器创建，可以直接使用
- 在全局作用域中，我们创建的对象都会作为window对象的属性值来使用
  创建的函数都会作为window对象的方法来使用

###### 变量的声明提前

- 使用 var 关键字声明变量，会在所有的代码执行之前被声明（但是不会赋值，会在赋值语句处赋值）

- 但是如果不使用 var 关键字声明，则变量不会被声明提前
  函数的声明提前

- 使用函数声明形式创建函数

  ```
  function 函数（）{
  }     (函数声明会被提前调用)
  对比例子：
  var fun2 = function（）{
  }    （使用函数表达式创建的函数，不会被提前调用）
  他会在所有的代码执行之前就被创建，所以可以在函数声明前来调用函数
  ```

- 全局作用域中的变量都是全局变量，在页面的任何部分都可以访问到

###### 函数作用域

- 调用函数时，创建函数作用域，函数执行完毕后，函数作用域销毁

- 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的

- 在函数作用域中可以访问到全局作用域变量
  但是在全局中无法访问到函数作用域变量

- 当在函数作用域中操作一个变量，他会先在自身的作用域中寻找
  如果有就直接使用，如果没有就向“上一级”作用域寻找（函数中套函数的情况），直到找到为止，
  如果直到查找到全局作用域都未找到，就会报“ReferenceError”的错误
  在函数里如果想访问全局变量，可以访问window对象
  window.变量名

- 在函数作用域中，也有声明提前的特性

- 使用 var 关键字声明变量，会在所有的代码执行之前被声明（但是不会赋值，会在赋值语句处赋值）

- 函数声明也会在所有代码执行前被声明
  在函数中不使用 var 来声明变量，都会默认转换成全局变量来使用
  定义形参就相当于用 var 声明了变量

  ##### 31.debug

  ##### 32.this

  ​		解析器在调用函数，每次都会向函数的内部传递进一个隐含的参数，这个隐含的参数就是this，this指向是一个对象，这个对象我们称为“上下文对象”，根据函数调用不同，this会指向不同的对象。

  `以函数的形式调用，this永远都是window`

  `以方法的形式调用，this就是那个被调用对象`

  ```
  console.log（this.属性名）；
  ```

  this是动态的，根据调用者的不同，this所指的也不同

  ##### 33.想要大批量的创建对象

  如果有大量的重复代码则可以使用工厂方法来创建对象

  ```
  	function createPerson（name，age）{
  var obj = new Object();
  		obj.name=name,
  		obj.age=age
  			return obj;
  	}
  	var obj2=creatPerson(tom，34);
  ```

```
	`创建一个写对象的函数，每当想创建新的对象的时候，只需var一个新的变量，来调用这个函数。使用工厂方法使用的构造函数都是object，所以创建的对象都是object，导致无法区分创建的对象。`
```

##### 34.构造函数（加new就是构造函数，不加就是普通函数）

构造函数就是一个普通的函数，创建方式和普通函数没区别
不同的是构造函数习惯上首字母大写

- 构造函数和普通函数的区别就是调用方式不同
  普通函数是直接调用，而构造函数则需使用new关键字来调用

  ```
  function Person(name, age) {
            this.name = name,
                this.age = age
        }
        function Dog(name, age) {
            this.name = name,
                this.age = age
        }
        var per = new Person("tom", 34);
        var dog = new Dog("tom", 34);
        console.log(per);
        console.log(dog);
  ```

  

  ###### 构造函数执行流程

  1.立刻创建一个新的对象
  2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引入新建对象
  3.逐行执行函数中的代码
  4.将新建的对象作为返回值返回
  使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类（Person）
  把通过一个构造函数创建的对象，称为该类的实例（per）
  使用“instanceof”可以检查一个对象是否是一个类的实例
  如果是返回true，反之返回false

  ```
  console.log(per instanceof Person);
  console.log(per instanceof Object);
  ```

  ​	注意：任何的对象都是Object的实例

  ###### this的情况：

- 以函数的形式调用，this永远都是window

- 以方法的形式调用，this就是那个被调用对象

- 以构造函数的形式调用时，this就是新创建的那个对象

  ##### 35.在构造函数中定义一个方法

  每当调用一次构造函数时，方法也就被重新创建一次，而这些方法是一样的（并非同一个）
  为了节省资源，可以把方法定义在全局中（创建新的函数），再在构造函数中调用这个新构造的函数。

  例如：

       function fun() {
                alert("我的名字是" + this.name + "我的年龄是" + this.age);
            }
            function Person(name, age) {
                this.name = name,
                    this.age = age
                this.sayname = fun;
            }
       var per = new Person("tom", 34);
       		 per.sayname();
        			console.log(per);


  ##### 36.把函数定义在全局作用域中，他污染了全局作用域的命名空间

  而且定义在全局作用域中，也很不安全。故尽量不要在全局中定义

  ###### 原型prototype

  ​		我们所创建的每一个函数，解析器都会向函数中添加一个prototype属性，这个属性对应着一个对象,这个就是我们所谓的原型对象，如果函数作为普通函数调用,此时这个属性就无用。但是当函数作为构造函数调用时,他所创建对象中都会有一个隐含的属性，都会指向该构造函数的原型对象,我们可以通过__proto__来访问。
  `mc.__proto__.__proto__  （找原型的原型）`

    	 function Person(name, age) {
    	   }
    	 function Dog(name, age) {
    	      
    	   }
    	var per = new Person();
    			console.log(per.__proto__)；
    			console.log(Person.prototype);

  ​		原型对象就行相当于一个公共区域，所有同一个类实例都可以访问到这个原型对象，故可以向原型对象中添加一些公共的属性。
  ​		当我们访问对象的属性或者方法时，会先在自身对象中寻找，如果有则直接使用
  ，如果没有就去原型对象中找。
  添加方法如下：

  ​		Person.prototype.a=123;(向原型对象中添加a属性)

      	Person.prototype.fun = function () {
                alert("我的名字是" + this.name + "我的年龄是" + this.age);
            }
            function Person(name, age) {
                this.name = name,
                    this.age = age
        }
        var per = new Person("tom", 34);
        per.fun();
        console.log(per);

  ##### 37.检查一个对象是否自己有某个属性，而不是在原型对象中存在

  ###### 检测在原型对象中是否存在某个属性，用“in”

  ```
  例如：
  console.log（“name” in  myclass））
  可以使用    hasOwnProperty（）
  即：
   mc.hasOwnProperty（"name")
  ```

  只有对象自身含有这个属性，才会返回true。
  原型对象也是对象，所以他也有原型，当我们使用一个对象的属性时，会先在自身中寻找，如果自身有，就直接使用，如果没有就去原型中找，如果没有，再去原型的原型的对象中去找，直到找到

  ```
  object对象的原型（object没有原型，故找到他就到头了）
  ```

  ##### 38.toString

  直接在页面中打印一个对象时，事件上是输出对象的toString（）方法的返回值之
  如果希望在输出对象时不希望以[boject,object]的方法输出，可以为对象添加一个
  tostring（）方法

  ```
    function Person(name, age) {
            this.name = "name";
            this.age = "age"
        }
        Person.prototype.toString() == function () {
            return "Person[name" + this.name + ",age=" + this.age+"]";
        }
        var per = new Person("tom", 23);
        console.log(per);
  ```

  ##### 39.垃圾回收（GC）

  ​		就像人生活得时间长了会产生垃圾，程序运行过程中，也会产生垃圾，垃圾过多会导致程序运行过慢，所以需要一个垃圾回收机制。当一个对象没有放任何的变量说着属性对其进行引用，那么我们将永远不会对其进行引用，这种对象过多会占用大量的运行空间，导致程序运行变慢，所以这种弄垃圾必须进行清理。

  在js中有自动的垃圾回收机制，会自动销毁垃圾对象，我们不需要也不能进行垃圾回收

  但是浏览器不能判断对象是否有用，我们需要做的是把我们不再使用的对象设置为null即可

  ##### 40.数组（Array）

  ​		数组也是对象，与普通对象功能类似。不同的是普通对象是使用字符串作为属性名的，而数组使用数字作为索引（index）操作元素（索引从0开始）

  `因为数组存储于性能比对象好，所以在开发中常用数组来存储数据`

  ###### 创建数组对象

  ```
  var arr=new Array();
  ```

  ###### 向数组中添加元素

  语法：数组[索引] =值；

  ```
  arr[0]=10;
  //读取数组中的元素
  console.log(arr[0]);
  如果读取不存在的索引会返回未定义
  ```

  ###### 获取数组的长度

  使用 .length属性

  ```
  console.log(arr.length);
  ```

  对于连续的数组，使用length属性，可以测试出数组的长度。对于非连续的数组会获取最大的索引数加一，但是尽量不要创建非连续性数组。

  ###### 修改数组的长度

  ```
  arr.length=10;
  ```

  如果修改的length大于原长度，则多出的部分会空出来，反之如果小于原长度，则会删除。

  ###### 永远向数组最后一个添加元素

  语法：数组[数组.length]=数值;

  ```
  arr[arr.length]=70;
  ```

  ##### 41.字面量创建数组

  ```
  var arr = [];
  ```

  

  ###### 使用字面量创建数组，可以在创建时就指定数组中的元素

  ```
  var arr = [1,2,3,4,5,6];
  ```

  (使用构造函数创建数组时，也可以同时添加元素)var arr = new Array(1,2,3)

  ###### 创建数组中只有一个元素时，用字面量创建。用函数方式创建时，括号中的数字为数组长度

  ```
  var arr = new Array(10)   （创建一个长度为10 的数组）
  ```

  ###### 数组中的元素可以是任何值

  ```
  arr = ["hello",1];
  ```

  ###### 数组中的元素也可以是对象，也可以是函数

  ###### 数组中也可以放数组，这种数组我们称为二维数组（很少使用）

  ##### 42.数组的方法

  ###### push（）该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度	（vue）

  可以将要添加的元素作为方法的参数传递，这些元素将会自动添加到数组的末尾，并且该方法会将新数组的长度作为返回值返回，

  参数就是需要添加进数组的项目。

  ```
  arr.push("hello","tom");
  ```

  ###### pop（）该方法可以删除数组中最后一个元素,并将删除的这个元素返回	（vue）

  ```
  result= arr.pop();
  	console.log(result);（此时返回的是被被删除的这个元素）
  ```

  ###### unshift（）该方法会向数组开头添加一个或者多个的元素，并返回新数组的长度，并且向前面插入元素后，其他元素的索引会依次调整	（vue）

  ```
  arr.unshift("hello","tom");
  ```

######       		shift（）该方法可以删除数组的第一个元素，并将删除的值返回	（vue）

##### 43.数组的遍历

```
var arr = ["nike", "lisa", "tom", "jack","dam"];
      for (let i = 0; i < arr.length; i++) {
          console.log(arr[i]);
      }
```

##### 44.数组遍历例实例

```
function Person(name, age) {
          this.name = name;
          this.age = age
      }
      var per1 = new Person("tom", 17);
      var per2 = new Person("lisa", 21);
      var per3 = new Person("nike", 12);
      var per4 = new Person("daiv", 40);
      var Arr = [per1, per2, per3, per4];
      function adultArr(arr) {
          var newArr = [];
          for (let i = 0; i < Arr.length; i++) {
              var p = Arr[i];
              if (p.age < 18) {
                  newArr.push(p);
              }
          }
          console.log(newArr);
          return newArr;
      }
      adultArr();
```

##### 45.forEach方法

​		一般都是使用for循环去遍历数组，js中提供了forEach方法来遍历，forEach需要一个函数作为参数（常用匿名函数）像这种函数，由我们创建但是不由我们调用的函数，我们称为回调函数。

```
arr.forEach（function（）{
	}）；
```

​		数组中有几个元素，函数就会执行几次，每次执行时，浏览器就会将遍历的元素以实参的形式传递进来，我们可以定义个形参，来读取这些内容

###### 浏览器会在回调函数中传递三个参数：

第一个参数，就是当前正在比遍历的元素
第二个参数，就是当前正在遍历的元素的索引
第三个参数，就是正在遍历的数组

```
function Person(name, age) {
            this.name = name;
            this.age = age
        }
        var per1 = new Person("tom", 17);
        var per2 = new Person("lisa", 21);
        var per3 = new Person("nike", 12);
        var per4 = new Person("daiv", 40);
        var Arr = [per1, per2, per3, per4];
        Arr.forEach(function (value, index, obj) {
            console.log(value);
            console.log(index);
          

        });

（IE8以下浏览器不支持该属性）
```

##### 46.数组常用方法

###### slice（）

- 可以用来从数组中提取指定元素

- 参数：
  截取开始的位置，包含开始索引
  截取结束的位置，不包含结束索引    

  ```
     arr.slice(0,2);   （索引从0截取到2）
  ```

- 该方法不会改变原数组，而是将截取元素封装到一个新数组中返回。

- 结束第二个参数可以省略不写，此时会截取从开始索引，到结束索引

- 索引可以传递一个负值

  ```
  例：“-1”表示倒数第一个
  //	slice（-1）
  ```

###### splice（）	（vue）

- ###### 可以用于删除数组中的指定元素

  ```
  arr.splice(0,2);
  ```

- 使用splice会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回
  参数：
  第一个，表示开始位置的索引
  第二个，表示删除的数量
  第三个及以后，可以传递进去一些新的元素，这些元素将会自动插入开始索引位置的前面

  ```
  arr.splice(0,1，“tom”，“lisa”);
  ```

  也可以把删除元素个数（第二个参数）设置为0，后面接着写一些元素，这样就实现了新元素的插入。

  ```
  arr.splice(1,0，“tom”);
  ```

  ```
  例:（删除一个数组中重复的元素）
    var Arr = [1, 23, 4, 56, 7, 1, 3, 5, 46, 7, 4];
        //获取数组中每一个元素
        for (var i = 0; i < Arr.length; i++) {
            for (var j = i + 1; j < Arr.length; j++) {//获取当前元素后的元素
                //判断数组中的两个元素是否相等
                if (Arr[i] == Arr[j]) {
                    //如果相等则删除j
                    Arr.splice(j, 1);
                    //当删除了一个元素后，后面的元素会自动补位，
                    //此时将不会比较这个元素，出现了bug
                    j--;
                }
            }
        }
        console.log(Arr);
  ```

  ##### 47.数组的常用方法

  ###### concat（）

- 可以连接两个或者多个数组，并将新的数组返回

- 该方法不会对原数组产生影响

  ```
  var result = arr.concat(arr2);
  var result = arr.concat(arr2,arr3,arr4,"tom",);  （也可以添加新的元素）
  ```

  ###### join（）

- 该方法可以将一个数组转换成一个字符串，对原数组没有影响,把转换后的字符串作为结果返回

  ```
  var result = arr.join();
  ```

- 在join（）中可以指定一个字符串作为参数，这个字符串，会成为数组中元素的连接符，如果不指定连接符，则默认指定“，”作为连接符。如果写join（“”），则会用串链接。

  ###### reverse（）	（vue）

- 该方法用来翻转数组（前面到后面，后面到前面）

- 该方法会直接修改原数组

  ###### sort（）	（vue）

- 对数组的元素进行排序

  ```
  arr.sort();
  ```

- 也会影响原数组，原数组顺序会改变，默认按照Unicode编码进行排序

- 计时对于纯数字数组，使用sort（）进行排序，也会按照Unicode排序，所以可能会出现
  错误排序，所以可以自己来指定排序规则
  我们可以在sort（）中添加回调函数，来指定排序规则
  方法一：

  		arr.sort(function(a,b){
  				if（a>b）{
  					return 1;
  			} else{
  					return -1;	
  			}else{
  					return 0;	}
  					})

  方法二：

  ```
  rr.sort(function(a,b){
  return a-b;
  	})
  	（升序返回a-b，降序返回b-a）使用那个元素调用不确定，但是a一定在b前面
  ```

- 浏览器会根据回调函数返回值来决定元素顺序
  如果返回一个大于0的值，则元素会交换，
  如果返回一个小于0的值，则元素位置不变
  如果返回一个等于0的值，则元素位置不变。

  ##### 48.函数的方法

  ###### call（）和apply（）  （都是函数对象的方法）

- 当对函数调用这两个方法，都会调用函数执行

- 在调用call（）和apply（）方法时，可以将一个对象指定为第一个参数，那么此时这个对象将会成为函数执行时的this。

  ```
  function fun(){
  		alert(this);
  			}
  fun();
  fun.call();      //这三种方法都可以调用函数，来执行函数
  fun.apply();
  
  var obj={name:"tom"};
  	fun.call(obj);   //这个参数是谁，函数中的this就是谁
  ```

  

- call（）方法可以把实参在对象之后，依次传递    fun.call(obj,1,2);    
  apply（）方法需要把实参封装到一个数组中统一传递   fun.apply(obj,[1,2]);

  ######  this 情况

- this以函数形式调用，this永远都是window

- this以方法的形式调用，this是调用方法的对象

- 与构造函数的形式调用，this是新创建的那个对象

- 使用call和apply方法是，this是指定的那个对象

  ##### 49.arguments

  在调用函数时，浏览器每次都会传递进两个隐藏的参数

- 函数的上下文对象 this

- 封装实参的对象 arguments
  arguments是一个类数组对象，他也可以通过索引来操作数据，也可以获取长度
  ，调用函数时，我们所传递的实参都会在arguments中保存。

- arguments.length 可以用来获取实参的长度

  ```
  console.log（arguments[0]）;
  ```

- 即使不定义形参，也可以通过arguments来使用实参,但是比较麻烦

  ```
  arguments[0]     arguments[1]
  ```

- 他里面有一个属性叫做callee（），这个属性对应一个函数对象，就是当前正在指向的函数对象

  ```
  console.log（arguments.callee）;
  ```

  ##### 50.Data对象

- 在js中使用data对象来表示时间

  ```
  var d = new Data（）；
  ```

- 如果直接使用构造函数创建一个data对象，则会封装为当前代码执行的一个时间

- 如果想创建一个指定时间对象，则需要在构造函数中传递一个表示时间的字符串作为参数

  ```
  var d2 = new Data("12/3/2021 11:11:11");
  ```

- 日期格式  月份/日/年 时：分：秒

  ```
  var data = d2.getDate();
  //	getDate()    获取当前日期对象是几号
  //	getDay()   获取当前日期对象是周几（会返回一个0到6的数值，其中表示周日）
  //	getMonth()   获取当前日期对象的月份（会返回一个0到11的数值，0表示一月，往后以此类推）
  //	getFullYear()  获取当前日期对象的年份
  //	getTime()   获取当前日期对象的一个时间戳
  ```

  

- 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒，到当前日期
  所花费的毫秒数（1秒等于1000毫秒）

- 计算机底层在保存时间时，使用的都是时间戳
  var time = d2.getTime();
  console.log(time/1000/60/60/24/365);

- 获取当前的时间戳

  ```
  time = Data.now();   //获取当前代码执行时的时间
  console.log(time);
  （可以利用获取当前时间戳来测试代码的性能）
  在想测试的代码片段的开始和结束分别写一个获取当前时间戳，然后做两个时间戳的差
  ```

  ##### 51.Math对象

  他不是构造函数，它属于工具类，不需要创建对象，他里面封装了数学属性（拿来即用）	

  ######  大写的属性都是常量

  ```
  Math.PI   表示π（属性查表可知）
  ```

  ###### abs()可以用来计算一个数的绝对值

  ```
  console.log（Math.abs(-1)）;
  ```

  ######  Math.ceil();   （小数部分只要有数值，就向上进1）可以向上取整

  ######  Math.floor(); 可以向下取整   （小数点以后全部省略）

  ###### Math.round()；可以对一个数进行四舍五入

  ###### Math.random();可以生成一个0到1之间的随机数  （不包括1和0）

- 生成一个0到10 的随机数

  ```
  Math.round ( Math.random( )*10 )；
  ```

- 生成一个0到x之间的随机数

  ```
  Math.round ( Math.random( )*x )；
  ```

- 生成一个x到y之间的随机数

  ```
  Math.round ( Math.random( )*（y-x） )+x；
  ```

- max（）可以获取多个数中的最大值

  ```
  var max = Math.max(10,20,30,40);
  ```

- min（）可以获取多个数中的最小值

  ```
  var min = Math.min(10,20,30,40);
  ```

- Math.pow(x,y); 返回x的y次幂

- Math.sqrt()；用于对一个数的开方计算

  ##### 52.包装类

  在js中为我们提供了三个包装类，通过这三个包装类可以把基本数据类型转换成对象（临时的）

- String（）  可以将基本数据类型转换为String对象

- Number（）  可以将基本数据类型转换为Number对象

- Boolean（）  可以将基本数据类型转换为Boolean对象
  应用语法：

  ```
  var num = new Number(3);
  var str = new String("hello");
  var bool = new Boolean(ture);
  （变成对象数据类型后，就可以为对象添加属性了）
  ```

  注意：在开发中，不会使用基本数据类型的对象，如果使用基本数据类型对象，在做一些
  比较时，可能会带来一些不可预料的结果。
  		当我们对一些基本数据类型去调用一些方法时，浏览器会临时利用包装类，将其转化成对象
  然后再调用对象的属性,调用完成后，再将其转换为基本数据类型。

  ```
  例：s = 123;
  	s = s.toString();
  ```

  ##### 53.字符串的方法

  字符串在底层是以字符数组保存的，一个字符就是数组中的一个元素
  `length可以用来获取字符串的长度（他是一个属性）`

- charAt（）
  可以返回一个字符串中指定位置的字符

  ```
  str = "hello";
  var result = str. charAt(0);
  可以返回字符串中指定位置的字符，根据索引来获取指定位置的字符
  （但是这种方法比较麻烦，可以直接用[]来索引）
  ```

- charCodeAt（）
  可以获取指定位置的字符编码

- fromCharCode（）
  可以根据字符编码来获取字符

  ```
  var result = String.fromCharCode（72）;  （编码为10进制）
  （通过string对象来调用）
  如果想用16进制的数应该再在数字前加上个0x
  var result = String.fromCharCode（0x2570）;  
  ```

- concat（）
  可以用来链接两个或多个字符串,作用与+相同，并且不会影响原字符串

- indexOf（）
  该方法可以检索一个字符串中是否有某个内容

  ```
  result = str.indexOf("想要查找的内容");
  ```

  如果字符串中含有该内容，则会返回第一次出现的索引，如果没找到指定的
  内容，则会返回-1。
  可以指定开始查找的位置

  ```
  result = str.indexOf(“h”，1);
  （从第一个位置开始找h）
  ```

- lastIndexOf（）
  该方法用法和indexof用法相同，不同的是indexof是从前往后找，lastindexof是从后往前找。他也可以指定位置查找。

  ```
  result = str.lastindexOf(“h”，1)
  ```

- slice（）
  可以在字符串中截取制定的内容,不会影响原字符串，而是将截取的内容返回

  ```
  str.slice(0,3);
  ```

  参数：（0为开始位置，3为结束位置）如果省略第二个参数，就会截取到后边所有的，也可以传递一个负数作为参数，负数就会从后面开始计算 。

- subString（）
  可以用来截取一个字符串，与slice类似
  参数：开始截取位置的索引（包括开始位置），结束位置索引（不包括结束位置）
  但是与slice不同的是substring不能接收负值作为参数，如果传递了一个负值参数，则默认使用零。而且他会自动调整参数位置，如果第二个参数小于第一个参数则会交换位置。

- substr（）
  用来截取字符串，对原数组没影响

  ```
  str.substr（1,3）
  ```

  参数：截取开始位置索引，截取的长度

- split（）
  把一个字符串拆分为一个数组
  参数：需要一个字符串作为一个参数

  ```
  str="abc，def，ghi";
  result=str.split（“，”）；  （根据“，”把字符串拆分为一个数组）
  如果传递一个空串（参数为“”），则会把每一个字符都拆分为一个参数
  ```

- toUpperCase（）
  把一个字符串都转换为大写，并返回

- toLowerCase（）
  把一个字符串都转换为小写，并返回

  ##### 54.正则表达式  （对象）

- 正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则
  或者提取出字符串中符合规则的内容

  ###### 创建正则表达式对象

  语法：var reg = new RegExp(“正则表达式”，“匹配模式”);  
  在构造函数中可以传递一个匹配模式作为第二个参数
  `i   忽略大小写`
  `g  全局匹配模式`

  ```
  var reg = new RegExp(“a”，“i”);
  （使用typeof检查，会返回object类型）
  var reg = new RegExp(a);    （这个表达式可以检测一个字符串中是否有a，有就会返回true）
  ```

  ######  正则表达式方法

  test（）  使用这个方法可以检查一个字符串是否符合正则表达式的规则
  如果符合就返回true不符合就返回false

  ```
  var result = reg.test(str);
  ```

  ##### 55.正则表达式语法

- 使用字面量来创建正则表达式
  var 变量 = /正则表达式/匹配模式  （不用加“”）

  ```
  reg = /a/i;  
  ```

  使用字面量创建更加简单，使用构造函数创建更加灵活（可以把变量作为参数）

  ###### 创建一个正则表达式，检查其中是否有a或b或c。

  `使用“|”表示“或”的意思`

  ```
  reg = /a|b|c/
  ```

  ###### 创建一个正则表达式中是否有字母

  `“[ ]”中的内容也是表示或的关系`

  ```
  reg = /[ab]/;
  ```

- [a-z]表示任意的小写字母

- [A-Z]表示任意的大写字母

- [A-z]表示任意字母

  ###### 检查一个字符串里是否含有abc或者adc或者aec

  ```
  reg = /a[bde]c/;
  ```

  ###### <!--[^]-->[^ ]除了

  reg = /[^ab]/;    表示除了ab以外的数字

  ###### 检查任意数字

  ```
  reg = /[0-9]/;
  ```

  ##### 56.字符串和正则的相关的方法

  split（）可以把字符串拆分为一个数组

  ###### 根据任意字符来拆分

- 方法中可以传递一个正则表达式作为参数，这样会根据正则表达式来拆分

  ```
  var str = "1a2b3c4c5e";
  var result = str.split(/[A-z]/);
  ```

  search（）可以搜索字符串中是否含有指定内容
  如果搜索到，则会返回第一次出现的索引数。如果搜索不到，则会返回-1，并且他不可以设置全局匹配，他只会查找第一个。

- 方法中可以传递一个正则表达式作为参数

  ```
  var str = "1a2b3c4c5e";
  var result = str.search(/a[bef]c/);
  ```

  match（）可以根据正则表达式，从一个字符串中符合条件的内容提取出来
  默认情况下match只会找到第一个符合要求的内容，找到后就会停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配所有内容。
  可以诶一个正则表达式设置多个匹配模式，顺序无所谓（var result = str.match(/[A-z]/ig);  ）
  match会将匹配到 的内容封装到一个数组中返回，即使只查询到一个结果

  ```
  var str = "1a2b3c4c5e";
  var result = str.match(/[A-z]/g);  
  ```

  replace（）可以将字符串中的指定内容替换为新的内容
  参数：第一个为原字符串中想替换的内容，第二个为想要换进去的内容	

  ```
  result = str.replace（“a”，“@-@”）；
  ```

- 被替换的内容可以接受一个正则表达式作为参数

  ```
  result = str.replace（“/a/g”，“@-@”）；
  ```

  把想换进去的字符串设置为空串，就会删除原字符串中想替换的内容

  ```
  result = str.replace（“/a/g”，“”）；
  ```

  ##### 57.量词，通过量词可以设置一个内容出现的次数

- 量词只对前面的一个内容起作用

  ```
  reg = /(ab){3}/    “添加括号，就可以表示ab出现三次”
  ```

- {n}  正好出现n次

  ```
  var reg = /a{3}/;
  ```

- 出现1到3次           {m，n}    表示出现n到m次

  ```
  var reg = /a{1，3}/;
  ```

- {m，}  表示m次以上

- “+”表示至少一个，相当于{1，}

  ```
  reg = /ab+c/
  -“*” 匹配任何包含零个或多个 n 的字符串。
  reg = /ab*c/
  ```

- 表示0个或者一个，相当于{0,1}

  ```
  reg = /ab？c/
  ```

- 检查一个字符串是否以a开头
  ^ 表示开头

  ```
  reg = /^a/   匹配开头的a
  ```

- $ 表示结尾

  ```
  reg = /a$/   匹配结尾的a
  如果在一个正则表达式中同时使用^和$,则要求表达式必须完全符合表达式
  reg = /^a$/
  ```

  ```
  例：
  创建一个正则表达式检查是否为一个手机号
  /* 手机号规则 */
        /*首位以1开头 */
        /* 第二位为3到9任意数字 */
        /* 三位以后任意写，但是长度必须为九位 */
        var phoneStar = "15541492580"
        var phoneReg = /^1[3-9][0-9]{9}$/;
        console.log(phoneReg.test(phoneStar));
  ```

  

- “.”表示任意字符
  当我们想表示查找“.”，可以使用转义字符“\”

  ```
  reg = /\./  ；
  ```

  注意，使用构造函数时，由于参数是字符串，而\是转义字符，如果需要使用\
  则需要用\\来表示。

- \w  表示任意字母数字，“_”

- \W  除了字母数字“_”

- \d   任意数字

- \D   除了数字

- \s    空格

- \S   除了空格

- \b   单词边界

- \B   除了单词边界
  创建一个正则表达式，来检查一个字符串中是否有单词child

  ```
  reg = /\bchild\b/；
  ```

  去除字符串前和尾部的空格

  ```
  var str = prompt("请输入一个用户名");
        /* 去除掉字符串前后的空格，就是使用空串来替换空格*/
        str = str.replace(/^\s*|\s*$/g, "");
        console.log(str);
  ```

  电子邮件的正则表达式

  ```
  var emaiReg = /^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/;
        var str = "abc.hello@qq.com";
        console.log(emaiReg.test(str));
  ```

  58，DOM（宿主对象）
  文档对象模型（Document Object Model）
  		整个网页就是文档，网页的每一部分都转化为对象（以便于用面向对象的形式操作），模型用于表示对象之间的关系。

  ```
  节点（Node），网页中的每一个部分都可以称为节点，构成html的基本单元
       				     nodeType         nodeValue
  文档节点：整个html文档   #document             9		    null
  元素节点：html文档中的标签    标签名              1  		    null
  属性节点：元素的属性（id，class）属性名        2
  文本节点：html标签中的文本内容  #text           3		文本内容
  ```

  DOM作用：用来操作网页

- 浏览器已经为我们提供文档节点，手机window对象属性，可以在界面中直接使用
  ，文档节点代表的是整个网页

- 获取到button对象  （element元素）


<body>
    <button id="btn">我是一个按钮</button>
    <script>
        var btn = document.getElementById("btn");
        btn.innerHTML = "Im a button";
        console.log(btn.innerHTML);
    </script>
</body>
59.事件
事件，就是用户和浏览器之间的一些交互行为（点击按钮，移动鼠标）

- 处理事件，可以在事件对应属性中，设置一些js代码，当事件被触发时，这些代码会执行
  <button id="btn" onmousemove="alert('点我干嘛？')">我是一个按钮</button>
    这种方法不推荐使用，会发生结构和行为耦合，不方便维护
    可以为按钮绑定处理函数的形式来相应事件,这样事件被触发时才会执行

- 获取按钮对象

  ```
     var btn = document.getElementById("btn");
  ```

- 绑定一个单击事件

  ```
  btn.onclick = function(){
  	alert("hello");
  	} ;
  ```

  `绑定一个单击事件的函数，称为单击响应函数`

  ##### 60.文档的加载

  浏览器在加载页面时，是按照自上到下的顺序，读取到一行就运行一行，如果把js标签写下body上面时，在代码执行时，页面还没加载。把js代码编写到页面下部就确保了js在页面加载完成后，再执行代码。

- onload 事件会在整个页面加载完成后才触发（给window绑定该事件）

  	window.onload = function(){
  	}

  把js代码都放进上面的函数中，这样可以确保代码都在页面加载完成后再执行

  ```
   window.onload = function () {
            var btn = document.getElementById("btn");
            btn.innerHTML = "Im a button";
            console.log(btn.innerHTML);
        }
  ```

  ##### 61.dom查询

  ###### 获取元素节点

   getElementById（）  通过id属性获取一个元素节点  （最常用）
   getElementsByTagName（）  通过标签名来获取一组元素节点
  上述方法会给我们返回一个类数组对象，所有查询到的元素都会封装到这个对象中，可以通过for循环遍历。即使查询到的元素只有一个，他也会封装到数组中。
  `（innerHTML 通过该属性可以获取到元素内部的HTML代码）`
  getElementsByname（）  根据name属性来获取一组元素节点
  `（innerHTML用于获取元素内部的html代码，对于自结束标签没有意义（单选框））`
  如果需要读取一个元素节点的属性，直接使用“元素.属性名”
  注意：class不可以使用这个方法来获取属性，想要读取时，用  .className  来获取

  ```
  <input id="oq" type="radio" value="man">
  	alert(inputs[i].type);
  ```

  ##### 62.获取父节点的属性

  parentNote
  `（innerText 该属性可以获取纯文本内容，不会带有标签）`
  获取前一个兄弟节点的属性   `（也可能获取到空白元素）`
  previousSibling
  获取下一个兄弟节点的属性
  nextSibling

  ###### 文本框的value属性值就是指文本框输入的内容	

  firstChild      第一个子节点属性

  ##### 63.单选框选中状态

  通过checked属性取反代码

  ```
  items[i].checked = ! items[i].checked
  ```

  在事件响应函数中，响应函数是给谁绑定的this就是谁 

  ##### 64.DOM查询的其他方法

- 获取body标签
  在document中有个body属性，他保存的是body属性

  ```
  	var body = document.body;
  ```

- document.documentElement   保存的是html根标签

- document.all  代表页面中所有元素  （head,body,script,title等等）

- 根据元素class属性值查询一组节点对象
  getElementByClassName("class名");
  `但是IE8以下会不兼容此方法`

- 获取指定的div，而不是获取整个界面所有的div
  document.querySelector();
  需要一个选择器的字符串来作为参数，可以根据一个css选择器来进行查找一个元素节点对象。
  `ie8浏览器也支持`
  使用该方法，他总会返回唯一的元素，如果满足条件的元素有多个，那么他只会返回
  第一个。

  ```
  var div = document.querySelector(“.box div”);
  var div = document.querySelector(“#box”);
  ```

  该方法和上述方法类似，但是不同的是，他会将所有符合的元素返回封装到一个数组里返回
  即使只有一个内容，也会封装成数组来返回。
  document.querySelectorAll();

  ##### 65.dom对象的增删改

- appendChild（）；创建节点

  ###### 第一步，创建元素节点     document.createElement（“标签名”）；

  它需要一个标签名作为参数，会根据标签名来创建元素节点对象
  ，并把创建好的对象作为元素名作为返回值

  ###### 第二步，创建文本节点      document.createTextNode（“文本内容”）；

  它需要一个文本内容作为参数，会根据该内容创建一个文本节点，并把洗的节点返回

  ###### 第三步，把文本节点添加到标签中（设置为其子节点）

  appendChild（）；    可以向一个父节点中添加一个新的节点
  用法：父节点.appendChild（子节点）    注意：不需要加引号

  ###### 第四步，把新节点添加进去

  父节点.appendChild（子节点）

- insertBefore（）； 在指定的子节点前面插入新的子节点（这个方法是父节点调用的）

  ```
  语法：
  父节点.insertBefore（新节点，旧节点）（不用写引号）
  ```

- replaceChild（）； 替换子节点，并且可以使用指定的子节点来替换子节点

  ```
  语法：
  父节点.replaceChild（新节点，旧节点）（不用写引号）
  ```

- removeChild（）；  删除子节点  （父节点调用）

  ```
  语法：
  父节点.removeChild（想删除的节点）;（不用写引号）
  常用：通过子元素，来获取其父元素
  子节点.parentNode.removeChild（想删除的节点）;
  ```

- 使用innerHTML 也可以完成增删改操作，但是这种方法修改“动静”太大，所以会和上面的方式结合来使用。

  ```
  var li = document.createElement("li");
               li.innerHTML = "辽宁";
               var city = document.getElementById("city");
                city.appendChild(li);
  ```

  ##### 66.小技巧

  ​		点击超链接以后，页面会跳转，这是超链接的默认属性，但是当我们不希望出现在这个特性时，只需要在响应函数后加上个  return false;   即可取消这个默认行为。

  ```
  也可以在href = “”；的引号里面写个    javascript：；即可。
  ```

  confirm()；
  		此方法可以弹出带有一个确认按钮和一个取消按钮的弹窗，需要一个字符串作为一个参数，这个字符串作为提示语来显示。点击确定时，会返回true，如果点击取消，则会返回false，此时
  可以使用个if选择，来决定下面的内容是否执行。

  ##### 67.操作内联样式（CSS）

  ```
  语法：
  元素.style.样式名 = 样式值；  注意：样式值需要是字符串（加上引号）
  但是如果css样式中含有“-”，这种名字在js中是不合法的。
  如果要使用，则需要把这个样式修改为驼峰命名法。
  通过style属性设置的都是内联样式，而内联样式具有较高的优先级，
  所以通过js修改的的样式往往会立即显示，但是如果在样式中写了“！ important”，
  则此时样式会有最高的优先级，即使通过js也不可以覆盖该样式，此时将会导致js样式修改无效
  ```

  读取当前的元素样式

  ```
  语法：
  元素.style.样式名 
  通过style属性读取和设置的内容都是内联样式，所以在样式表中的样式
  是无法读取到的。
  ```

  ##### 68.读取元素当前的样式（样式表中的样式）

  ```
  语法：
  元素.currentStyle.样式名
  他可以用来读取元素当前正在现显示的样式（不分内联还是样式表），如果当前元素没有样式，
  则会返回默认值。
  ```

  `注意：这个方法只有ie支持，其他浏览器均不支持，在其他浏览器中可以使用`
  getComputedStyle（）；`（此方法是window属性 ，因此可以直接使用）`
  这个方法需要两个参数：

  ```
  第一个：要获取样式的元素
  第二个：可以传递个伪元素，一般都用  null
  ```

  ​		这个方法会返回一个对象，对象中封装了当前元素的数值，所以需要通过对象来调用。如果获取的样式没有设置，则他会获取到真实的值，比如没有设置width，则他会获取一个长度。
  `但是该方法不支持IE8以下的浏览器，如果想要同时兼容ie和其他浏览器，可以自己写个函数`

```
通过上述两个方法读取的样式结果，都是只读的，不可以修改。
如果要修改只能通过style属性来修改。
```

##### 69.（重复内容）

```
获取body标签，可以直接就用document.body。直接就可以获取。
获取html标签，可以直接document.documentElement。直接获取。
document.all 可以获得页面中所有的元素（只有.length属性不会出错）
document.getElementsByTagName("*")（表示获取所有元素）
document.getElementsByClassName("")可以根据class来获取dom对象，
但是会有兼容问题。（不支持IE8，性能也很差）
获取指定标签中的指定元素的方法：
document.querySelector()
可以根据css选择器来查询一个元素节点对象
例：	document.querySelector(“.box1”)
	document.querySelector(“.box1 div”)
使用该方法只会返回唯一的元素，如果满足条件的元素有多个，那么只能返回第一个元素（往下就不找了）
如果想解决这个问题可以用document.querySelectorAll(“”)来解决，他可以把符合的元素
封装到数组中并返回。（即使返回的元素只有一个，他也会返回一个数组）
```

##### 70.其他样式操作属性

获取元素可见样式的属性（对元素操作，不是对document操作）

```
clientWidth （获取可见宽度）
clientHeight  （获取可见高度）
```

他们的返回值是不含单位的数值，并且他们所返回的值是包含内边距和内容区的，但是不包含外边距，
（他返回的值是由多个参数求和而来的），上面的两个属性是只读的（不可以通过赋值来进行操作）

```
offsetWidth  （可以获取元素整个的宽度，包括内容区，内边距和外边距）
offsetHeight  （同上）
offsetParent  （可以获取当前元素的定位信息）
```

如果不开启定位，则会返回body这个大父类。如果开启了定位，则会获取离当前元素最近的父类元素。

```
offsetLeft  （当前元素相对于其定位的父元素的水平偏移量）
offsetTop   （垂直偏移量）
scrollHeight   （获取元素的滚动区域的高度）
scrollWidth    （获取元素滚动区域的宽度）
scrollLeft   （可以获取水平滚动条滚动的距离）
scrollTop   （可以获取垂直滚动条的距离）
```

`（上述两个属性都是返回滚动条当前的距离，并非是滚动条的全部长度）`
注：滚动条也占宽度或者高度。

```
当满足 scrollHeight  - scrollTop   ==  clientHeight 这个等式时，说明这个滚动条到底了
当满足 scrollWidth  - scrollLeft  ==  clientWidth 这个等式时，说明这个滚动条到最右边了
input标签，的disabled属性，表示当前不可使用。用法disabled = "true/false"
onscroll事件会在滚动条滚的时候触发（可以用做监听事件）
```

##### 71.事件对象

###### 当事件响应函数被触发时，都会将一个事件对象作为实参传递进响应函数。

在事件对象中封装了，当前的相关事件的一切信息。比如：鼠标的位置，键盘的按键等等相关的参数
但是在IE8以下的浏览器中，并不会在实参中传递信息，而是成了window对象的属性。

```
onmousemove事件，该事件将会在鼠标移动的时候被调用。此时我们可以定义一个形参，用来接受相关的数据
```

clientX可以获取鼠标箭头的水平坐标位置。clientY可以获取鼠标箭头的垂直坐标位置。（只是相对于
浏览器窗口的可见区域的，当网页比浏览器窗口长时，窗口左上角永远是（0，0）点）
解决上述问题的新方法：

```
pageX和pagey,这两个是获取相对于网页的坐标，而不是相对于窗口坐标。（但是这两个属性在ie8中不被支持）
```

获取浏览器滚动条垂直滚动的距离方法：document.documentElement.scrollTop

##### 72.事件的冒泡（Bubble）

事件冒泡就是指事件的向上传导，当后代元素上的事件被触发时，他的祖先元素上的相同事件也会被触发。
`（小女孩的故事）`
在开发中大部分情况事件冒泡是有用的，但是也有无用的时候，现在就要取消事件对象
取消事件冒泡的方法：

```
可以通过事件对象来取消冒泡：event.cancelBubble = true （event为函数的参数）
```

##### 73.事件的委派

###### 创建新元素的方法：document.createElement（“标签名”）

我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素。
​事件的委派：指将事件统一绑定给元素的共同祖先，这样当后代元上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素响应函数来处理。事件委派可以减少事件的绑定次数，用来提高性能。但是可能会出现出触发事件不是我们想要元素的情况，这时候需要用到事件对象的target属性来解决。
event.target表示的是触发事件的元素，可以通过判断是否为想要的元素来解决上述问题。

##### 74.事件的绑定

使用onclick来绑定事件时，只能绑定一个函数，如果绑定多个函数则会自动覆盖住前面的函数，只执行最后的一个函数。

###### 但是可以通过 addEventListener（）来为元素绑定响应函数（监听事件）

```
此方法需要参数：
1.事件的字符串，注意不要on（比如在绑定单击函数时，常规用onclick，但是在监听事件里面就要用click，把字符串前面的on去掉）
2.回调函数，当事件触发时该函数会被调用
3.是否在补货阶段触发事件，需要一个布尔值，一般情况传false
```

使用addEventListener（）方法可以为一个元素的相同事件绑定多个响应函数。这样当事件被触发时，函数会按照绑定的顺序先后依次执行。

```
例：btn01.addEventListener（“click”，“function（）{  函数内容 }”，false）；
```

`注意此方法IE8以下的浏览器不支持。如果要兼容需要使用`
attachEvent（）来绑定事件（此方法只有ie兼容）。

```
他所需要的参数：
1.绑定事件的类型名称 ，与addEventListener不同的是，他不需要去除字符串on
2.绑定事件的回调函数
```

这个方法也可以同时为一个事件绑定多个函数，但是执行顺序是从后到前，与addEventListener（）正好相反。

```
addEventListener（）中的this是绑定事件的对象。而attachEvent（）中this是window。
callback（）调用回调函数的方法。callback.call(obj)指定调用对象
```

##### 75.事件的传播

###### 事件的传播分为三个阶段（ie9以上的浏览器，ie8以下的不存在捕获阶段）：

```
1.捕获阶段，由最外层的祖先元素，向目标元素进行事件捕获，但是默认此时不会触发事件。
2.目标阶段，事件捕获到目标元素（找到了想要的元素）。
3.冒泡阶段，事件捕获到目标元素后，开始在目标元素上执行触发的事件（依次触发事件）。
```

`如果希望在捕获阶段就执行触发事件，可以将addEventListener（）的第三个参数设置为true，但是在一般情况下不会希望在捕获阶段触发事件。`

##### 76.实现拖拽效果

###### onmousedown，表示鼠标被按下事件。

###### onmouseup，表示鼠标被抬起事件。

```
取消事件：document.onmousemove = null;但是要注意事件的叠加，为了解决可以给document绑定鼠标抬起事件。
但是也要注意取消鼠标抬起事件，可以用document.onmouseup = null;来解决。
```

固定鼠标光标在div上的位置的实现办法：（最好改变元素的位置，而不是改变鼠标位置）

```
求出一个div的偏移量：
		鼠标.clientX - 元素.offsetLeft = 鼠标相对于元素的水平位置量 （鼠标就是event）
		鼠标.clientY - 元素.offsetTop = 鼠标相对于元素的垂直位置量
当拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索。但是此时会导致这个拖拽功能的异常，
这是浏览器提供的一个默认行为，这时候如果不希望发生这个行为，可以用 return false；来取消这个默认行为（但是在ie8中不起作用）。
```

```
setCapture（）方法可以对事件进行捕获，当调用这个方法以后，这个元素会把下一次所有的鼠标按下相关的事件捕获到自己身上（但是只能在第一次有效）
releaseCapture（）方法可以对事件进行取消捕获。
```



##### 77.滚轮事件

鼠标滚轮滚动事件onmousewheel，在火狐中要使用DOMMouseScroll来实现滚动事件，并且必需得用addEventListener来绑定。

```
判断鼠标滚轮的滚动方向：event.wheelDelta  可以获得滚轮滚动的方向，向上滚是一个正值，向下滚是一个负值。
（但是这个属性火狐不支持）火狐支持：event.detail  方法，但是向下滚是负值，向上滚是正直。
```

###### clientHeight 用来获取当前元素的高度

当滚轮滚动时，浏览器滚动条也会发生滚动。这是浏览器的默认行为，如果需要取消则可以写return false，
但是应该注意如果使用addEventListener来绑定函数时，return false会不发生效果，此时应该通过event来取消默认行为
该方法为：

###### event.preventDefault（）；可以取消默认行为。（但是这个方法在ie8中不支持）

##### 78.键盘事件 

键盘事件一般会绑定给可以获得焦点的事件（input），或者是document

```
onkeydown 某个按键被按下。
对于这个方法来说，如果一直按着某个按键不松手，则事件会一直触发。
当这个方法连续触发时，第一次和第二次之间的间隔时间会长一点，其他的速度非常快，这种设计是为了防止误操作。
```

```
onkeyup 某个按键被松开。
```

通过event可以知道按键是那个：event.keyCode来获取按键编码（a—>65）
判断组合键的使用：altKey，ctrlKey，shiftKey 他们可以判断这三个按键是否被按下，如果被按下则会返回true。
在文本框中输入内容，属于onkeydown的默认行为，如果取消了默认行为，则文本不会出现文本

```javascript
Switch语句：
switch（参数）{
	case 值1： 执行内容；
		break；
	case 值2：执行内容；
		break；
}
```

##### 79.BOM

BOM是浏览器对象，BOM可以通过js来操作浏览器。用来完成对浏览器的操作。
BOM对象：

###### Window：

​	代表整个浏览器窗口，同时window也是网页中的全局变量

```
alert（）显示带有一个确定按钮的弹窗
prompt（）显示一个带有输入框的弹窗
confirm（）显示一个带有取消和确定按钮的弹窗
```

如果希望一段程序可以每间隔一段时间来执行，可以使用定时调用

```
setInterval（）方法表示定时调用，可以将一个函数每隔一段时间执行一次
参数：1.回调函数，该函数会每隔一段时间被调用
	 2.每次调用间隔的时间 （单位为毫秒）
setInterval（function（）{  }，1000）
这个方法会返回一个number类型的数字，这个数字用来作为这个定时器的唯一标识（给这个定时器起个名）
var time = setInterval（function（）{  }，1000）
可以通过调用clearInterval（）来关闭某个特定的定时器
这时候需要把那个number作为参数传给clearInterval（time）。该方法可以接受任意参数，如果参数是计时器名字则会停止该计时器，如果不是计时器名字也不会报错。
```

`在开启定时器之前，可以将当前元素的上一个定时器关闭，这样就可以避免多个定时器同时运行的情况`
`还可以用定时器来解决div滑块移动速度不均匀问题。`
-setTimeout（）方法表示延时调用，隔一段时间后会调用，并且只会调用一次。

```javascript
setTimeout（function（）{  }，1000）
关闭一个延时调用：clearTimeout（）具体用法同上述定时调用，也需要传个参数。
注意：延时调用和定时调用也可以相互代替，定时调用使用的比较多。
```

##### Navigator：

​	代表当前浏览器的信息，通过该对象可以来识别不同的浏览器

```
navigator.appName 识别不同的浏览器（网景公司）
```

但是由于历史问题，此对象中的大部分属性已经不能帮我们来识别浏览器了。
一般我们只会使用userAgent（等价于浏览器）来判断浏览器信息。

```
userAgent就是一个字符串，这个字符串中包含用来描述浏览器的信息，不同的浏览器有不同的信息
navigator.userAgent
```

可以通过正则表达式来判断浏览器标识：

```
if（/firefox/i.test(navigator.userAgent)）{  }
在ie11里将微软和ie相关的标识都已经去除了，故不能用这个属性来判断了。如果navigator.userAgent不能判断出浏览器标识了
```

但是还可以通过一些浏览器中特有对象，来判断浏览器信息

```
例：window.ActiveXObject  这个对象只有IE中有，但是IE11中不支持该方法判断。
但是可以通过判断window对象中有无这个属性来判断是否为IE浏览器
	（“ActiveXObject”in window）
```

###### Location：

​	代表当前浏览器的地址栏，通过Location可以获取地址栏信息，来跳转界面。如果直接打印location，则可以获得当前页面的完整路径。也可以反向赋值，把location的属性赋值为其他路径，则页面会跳转到其他界面。

```
location.assign（）方法可以跳转到其界面，作用效果和上述的赋值一样
location.reload（）方法可以重新加载文档，起到刷新作用。
```

当想强制清空缓存刷新的时候（比如刷新后输入框的输入内容还在），这时候需要在reload（）中
传一个true参数，即location.reload（true）此时便可以强制清空缓存刷新。

```
location.replace（）新的文档替换当前的文档。
可以使用新的页面来替换当前的页面，也会跳转页面，但是不会生成历史记录，即不会有返回功能。
```

###### History：

​	代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私的原因，该对象不可以获取具体的历史记录。但是只能操作浏览器前进还是后退，该操作只在当次访问有效。

```javascript
history.length 属性可以获取当前访问链接的数量
history.back（）方法可以返回上一个界面
history.forward（）方法可以跳转到下一个界面
history.go（）方法可以用来跳转到指定界面，需要一个整数作为参数
参数为1时表示向前跳一个界面，参数为-1时表示向后跳转一个界面，以此类推。
history.go（1）
```

##### Screen：

​	代表用户的屏幕信息，通过该对象获取到用户显示器的相关信息
这些对象都是作为window对象的属性来使用（注意：描述的时候用大写，使用的时候是小写）

#####  80.ul标签去除点：list-style：none；

```
margin是外边距（第一个参数为上下外边距，第二个参数为左右外边距），padding是内边距。
浮动属性：float：left（左浮动），right（右浮动），none（不浮动），inherit（继承父元素浮动）
裁剪溢出的内容：overflow：hidden；
细节问题：文档流设置宽高，不起作用。
设置透明度：opacity：1；为不透明，0.5为半透明。
	(index = this.num)
```

##### 81.类的基础操作

一行代码可以同时修改多个样式的实现思路：
可以提前写好多个class属性，然后通过className来切换class名称来实现样式切换效果。此时浏览器只需要渲染一次，并且性能较好，而且这种方式可以使表现和行为具体分离。

```javascript
例：box1.className = "b2";
```

如果想保留原来的样式，并且想增添新样式则可以用“+=”来实现

```javascript
box1.className += " b2";  （注意b2前面有空格）
```

正则表达式new RegExp（）用法。（重新构造出一个正则表达式）

##### 82.折叠导航栏的实现思路

可以通过不同的class来定义不同的高度，最后切换class来实现导航栏的展开和折叠。（注意单击事件函数的绑定位置）
注意：当一个方法的回调函数开始执行的时候，说明前面内容已经执行完了。

##### 83.JSON

​		js对象只有js认识，其他语言都不认识。（这时候就需要一个中间媒介来实现语言间的通信）JSON就是一个特殊格式的字符串，这个字符串可以被任何语言来识别，并且可以转换为任意语言中的对象。JSON在开发中主要用来不同语言中数据的传递。（JavaScript Object Notation）
`JSON和JS对象一样，只不过JSON中属性名必须加双引号（js中可以不加双引号）`

###### JSON分类：

```
1.对象{}
2.数组[]
```

###### JSON中允许的值：

```
1.字符串
2.数值 
3.布尔值 
4.null 
5.对象（普通对象，不包括函数） 
6.数组
```

###### 把JSON字符串转换成js对象

`在js中为我们提供了一个工具类“JSON”，这个对象可以帮助我们把一个JSON转换为js对象，也可以把`
`js转换为JSON。`

> + 把JSON转换为js对象

```
JSON.parse(); 
```

他需要一个JSON字符串作为参数，会将该字符串转换为js对象。

```javascript
var json = '{"name":"小明","age":18}'
var obj = JSON.parse(json);
```

> + 把js对象转JSON

```
JSON.stringify();
```

需要一个js对象作为参数，注意这个js对象的属性名一定要加上引号。

```javascript
var obj = {"name":"小明","age":18};
var json = JSON.stringify(obj);
```

`可以注意：JSON这个对象在ie7及一下的浏览器不支持。`

可以使用eval()这个函数来进行兼容。

eval();这个函数可以用来执行一段字符串定时的JS代码，并将结果返回

```javascript
var str = "alert("hello world!")"
eval(str); 把字符串str作为参数传进去，则字符串的内容会被执行。
```

如果eval()执行的字符串中含有{}，则他会把{}当成代码块，来执行。如果不希望他把字符串
看做代码块，则可以在字符串前后各加一个括号。

```
eval("("+str+")")
```

eval()；函数的功能很强大，但是在开发中尽量不要使用。他的执行性能比较慢，并且还具有安全隐患。如果需要兼容ie7及一下的JSON操作，可以引入外部js文件来解决（现成的文件）。